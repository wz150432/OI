# 组合数计算方法

组合数 $C_a^b$（也记为 $\binom{a}{b}$ ）是组合数学的核心概念，描述 “从 $a$ 个元素中选 $b$ 个的方案数”，公式为 $C_a^b = \frac{a!}{b!(a-b)!}$（当 $0 \leq b \leq a$ 时，否则为 $0$）。在算法竞赛（OI）中，组合数的计算因**数据范围**、**模数条件**的不同，需要选用不同方法。本文将介绍四种典型的组合数计算技巧，并补充关键定理的证明。

## 一、递推法：小范围组合数

### 适用场景
$a, b \leq 2000$ 左右，需多次查询小范围组合数（支持模数运算）。

### 原理
利用杨辉三角的递推性质：
$$
C_a^b = C_{a-1}^{b-1} + C_{a-1}^b
$$

边界条件为 $C_a^0 = C_a^a = 1$。通过递推预处理所有小范围的组合数，查询时直接取值。

### 递推式的证明
**组合意义或代数运算均可证明**：

- **组合意义**：从 $a$ 个元素中选 $b$ 个的方案，可分为“包含某一特定元素”和“不包含该元素”两类：
  - 包含特定元素：需从剩下 $a-1$ 个元素中选 $b-1$ 个，方案数为 $C_{a-1}^{b-1}$；
  - 不包含特定元素：需从剩下 $a-1$ 个元素中选 $b$ 个，方案数为 $C_{a-1}^b$。
  两类方案无交集且覆盖所有可能，故 $C_a^b = C_{a-1}^{b-1} + C_{a-1}^b$。

- **代数运算**：
  对 $C_{a-1}^{b-1} + C_{a-1}^b$ 通分并化简：
  $$
  \begin{align*}
  C_{a-1}^{b-1} + C_{a-1}^b &= \frac{(a-1)!}{(b-1)!(a-b)!} + \frac{(a-1)!}{b!(a-b-1)!} \\
  &= \frac{(a-1)! \cdot b + (a-1)! \cdot (a-b)}{b!(a-b)!} \\
  &= \frac{(a-1)! \cdot a}{b!(a-b)!} = \frac{a!}{b!(a-b)!} = C_a^b
  \end{align*}
  $$

### 代码实现
```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 2010;
const int MOD = 1e9 + 7;

int t;
int C[N][N];

void init() {
    for (int i = 0; i < N; i ++ )
        for (int j = 0; j <= i; j ++ )
            if (!j) C[i][j] = 1;
            else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
}

int main() {
    cin >> t;
    init();
    while (t -- ) {
        int a, b;
        cin >> a >> b;
        cout << C[a][b] << endl;
    }
    return 0;
}
```

### 分析
- 预处理时间复杂度 $O(N^2)$，查询时间 $O(1)$。
- 优点：实现简单，适用于小范围多次查询。
- 缺点：当 $a, b$ 极大（如 $10^5$）时，数组无法存储，时间/空间复杂度爆炸。

## 二、阶乘+逆元：较大范围、模数为质数

### 适用场景
$a \leq 10^5$，模数 $p$ 是质数（且 $p > a$，避免阶乘含 $p$ 导致逆元不存在），需多次查询。

### 原理
组合数公式可表示为：
$$ C_a^b \equiv \frac{a!}{b!(a-b)!} \mod p $$
若 $p$ 是质数，预处理**阶乘** $\text{fac}$ 和**阶乘的逆元** $\text{inv}$，查询时直接计算 $\text{fac}[a] \times \text{inv}[b] \times \text{inv}[a-b] \pmod p$。

如何 $O(n)$ 预处理可以详见我的另一个文章 [Modular Multiplicative Inverse](https://www.cnblogs.com/wz150432/articles/19066442)

### 代码实现
```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e5 + 10;
const int MOD = 1e9 + 7;

int t;
int fac[N], inv[N];

void init() {
    fac[0] = inv[0] = inv[1] = 1;
    // 线性求逆元
    for (int i = 2; i < N; i ++ ) 
        inv[i] = (1ll * (MOD - MOD / i) * inv[MOD % i]) % MOD;
    // 预处理阶乘和阶乘的逆元
    for (int i = 1; i < N; i ++ ) {
        fac[i] = (1ll * fac[i - 1] * i) % MOD;
        inv[i] = (1ll * inv[i - 1] * inv[i]) % MOD;
    }
}

int main() {
    cin >> t;
    init();
    while (t -- ) {
        int a, b;
        cin >> a >> b;
        cout << (1ll * fac[a] * inv[b] % MOD) * inv[a - b] % MOD << endl;
    }
    return 0;
}
```

### 分析
- 预处理时间复杂度 $O(N)$，查询时间 $O(1)$。
- 优点：支持 $10^5$ 级别大范围，多次查询高效。
- 缺点：依赖“模数为质数”，且当 $a$ 接近模数时可能失效（因 $b!$ 可能含模数因子，逆元不存在）。

## 三、卢卡斯定理（Lucas）：大组合数、小质数模数

### 适用场景
$a, b$ 极大（如 $10^{18}$），但模数 $p$ 是较小的质数（如 $10^5$ 级别）。

### 原理
**卢卡斯定理**：若 $p$ 是质数，则
$$ C_a^b \mod p = C_{a \mod p}^{b \mod p} \times C_{\lfloor a/p \rfloor}^{\lfloor b/p \rfloor} \mod p $$
递归地将“大组合数”分解为“小组合数的乘积”，直到 $a, b$ 小于 $p$ 后，用小范围组合数计算。

### 卢卡斯定理的证明
核心思路是利用**模 $p$ 的二项式展开性质**与**多项式系数对应关系**：

1. **模 $p$ 的二项式性质**：
   对质数 $p$，当 $1 \leq k \leq p-1$ 时，$C_p^k = \frac{p!}{k!(p-k)!}$。由于分子含因子 $p$，而分母 $k!(p-k)!$ 与 $p$ 互质（$k < p$ 且 $p$ 是质数），故 $C_p^k \equiv 0 \pmod{p}$。因此：
   $$
   (1+x)^p \equiv 1 + x^p \pmod{p}
   $$

2. **$n, m$ 的 $p$ 进制分解**：
   设 $n = k \cdot p + r$（其中 $0 \leq r < p$），$m = l \cdot p + s$（其中 $0 \leq s < p$）。

3. **展开 $(1+x)^n$ 模 $p$**：
   $$
   (1+x)^n = (1+x)^{k \cdot p + r} = \left[(1+x)^p\right]^k \cdot (1+x)^r
   $$
   代入 $(1+x)^p \equiv 1 + x^p \pmod{p}$，得：
   $$
   (1+x)^n \equiv (1 + x^p)^k \cdot (1+x)^r \pmod{p}
   $$
   再对 $(1 + x^p)^k$ 和 $(1+x)^r$ 分别二项式展开：
   $$
   (1 + x^p)^k = \sum_{i=0}^k C_k^i \cdot x^{p \cdot i}, \quad (1+x)^r = \sum_{j=0}^r C_r^j \cdot x^j
   $$
   因此，$(1+x)^n$ 模 $p$ 的展开式为：
   $$
   (1+x)^n \equiv \left( \sum_{i=0}^k C_k^i \cdot x^{p \cdot i} \right) \cdot \left( \sum_{j=0}^r C_r^j \cdot x^j \right) \pmod{p}
   $$

4. **比较 $x^m$ 项的系数**：
   另一方面，直接展开 $(1+x)^n$ 的二项式定理为：
   $$
   (1+x)^n = \sum_{t=0}^n C_n^t \cdot x^t
   $$
   我们需要找到 $x^m = x^{l \cdot p + s}$ 项的系数。在上述展开式中，只有当 $p \cdot i + j = l \cdot p + s$ 时，才会产生 $x^{l \cdot p + s}$ 项。由于 $0 \leq j < p$，故唯一解为 $i = l$，$j = s$。
   因此，$x^m$ 项的系数为 $C_k^l \cdot C_r^s \pmod{p}$。

   而直接展开式中 $x^m$ 项的系数是 $C_n^m \pmod{p}$。两者系数必须相等，故：
   $$
   C_n^m \equiv C_k^l \cdot C_r^s \pmod{p}
   $$
   其中 $k = \lfloor n/p \rfloor$，$l = \lfloor m/p \rfloor$，$r = n \bmod p$，$s = m \bmod p$ 。
   
   卢卡斯定理得证！

### 代码实现
```cpp
#include <bits/stdc++.h>

#define int long long

using namespace std;

int t;
int p;

// 快速幂求逆元（费马小定理）
int qpow(int a, int b) {
    int res = 1;
    for (; b; b >>= 1) {
        if (b & 1) res = (res * a) % p;
        a = (a * a) % p;
    }
    return res;
}

// 计算小范围组合数 C(a,b) mod p
int C(int a, int b) {
    int ans = 1;
    for (int i = 1, j = a; i <= b; i ++, j -- ) {
        ans = (ans * j) % p;            // 分子乘j
        ans = (ans * qpow(i, p - 2)) % p; // 分母乘i的逆元
    }
    return ans;
}

// 卢卡斯定理递归计算 C(a,b) mod p
int lucas(int a, int b) {
    if (a < p && b < p) return C(a, b);
    return (lucas(a / p, b / p) * C(a % p, b % p)) % p;
}

signed main() {
    cin >> t;
    while (t -- ) {
        int a, b;
        cin >> a >> b >> p;
        cout << lucas(a, b) << endl;
    }
    return 0;
}
```

### 分析
- 时间复杂度：递归深度为 $\log_p a$，每次递归内计算小范围组合数为 $O(p)$，整体约 $O(p \log_p a)$。
- 优点：能处理**指数级**的 $a, b$，只要模数是小质数。
- 缺点：模数必须是质数，递归有一定常数开销。

## 四、高精度组合数：无模数、精确值

### 适用场景
需要计算 $C_a^b$ 的**精确值**（非模运算），且结果可能极大（超出整型范围）。

### 原理
1. **质因数分解**：用**Legendre公式**计算组合数中每个质数的指数：质数 $p$ 在 $C_a^b$ 中的指数为
   $$ \sum_{k=1}^{\infty} \left( \left\lfloor \frac{a}{p^k} \right\rfloor - \left\lfloor \frac{b}{p^k} \right\rfloor - \left\lfloor \frac{a-b}{p^k} \right\rfloor \right) $$
2. **高精度乘法**：将所有质因数按指数幂次相乘，得到最终的高精度结果。

### 代码实现

读者可直接更改上方的 `BASE` 直接变成压位高精度，但是注意如果 `BASE` 开的较大的话一定要乘的时候开 *long long* 不然会溢出，还有就是输出的时候除了最高位及 `res.a.back()`其他要记得加前导零，比如 `printf("%0xd", res.a[i])`当你采用`10^x`进制时候。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 5010;
const int BASE = 10;  // 高精度基数（10进制）
const int WIDTH = 1;

int cnt;
vector<int> primes;
bool vis[N];

// 高精度数结构体：vector存储每一位（低位在前）
struct number {
    vector<int> a;

    number() : a(1, 0) {}

    number(int x) {
        if (!x) a.push_back(0);
        while (x) {
            a.push_back(x % BASE);
            x /= BASE;
        }
    }

    // 高精度乘法
    number operator*(const number& x) const {
        number res;
        res.a.resize(a.size() + x.a.size(), 0);
        for (int i = 0; i < a.size(); i ++ ) {
            int carry = 0;
            for (int j = 0; j < x.a.size() || carry; j ++ ) {
                int val = res.a[i + j] + carry;
                if (j < x.a.size()) val += a[i] * x.a[j];
                res.a[i + j] = val % BASE;
                carry = val / BASE;
            }
        }
        // 去除前导零（结果非零时）
        while (res.a.size() > 1 && !res.a.back()) res.a.pop_back();
        return res;
    }
};

// 高精度快速幂：计算 a^b
number qpow(number a, int b) {
    number res(1);
    for (; b; b >>= 1) {
        if (b & 1) res = res * a;
        a = a * a;
    }
    return res;
}

// 欧拉筛：预处理质数
void Euler_Sieve(int n) {
    vis[1] = 1;
    for (int i = 2; i <= n; i ++ ) {
        if (!vis[i]) {
            primes.push_back(i);
            cnt ++ ;
        }
        for (int j = 0; primes[j] <= n / i; j ++ ) {
            vis[i * primes[j]] = 1;
            if (i % primes[j] == 0) break;
        }
    }
}

// Legendre公式：计算质数p在n!中的指数
int get(int n, int p) {
    int res = 0;
    while (n) {
        n /= p;
        res += n;
    }
    return res;
}

int main() {
    Euler_Sieve(N - 1);  // 预处理质数

    int a, b;
    scanf("%d%d", &a, &b);
    number res(1);
    // 对每个质数，计算其在C(a,b)中的指数，再乘上对应幂次
    for (int i = 0; i < cnt; i ++ ) {
        int p = primes[i];
        int s = get(a, p) - get(b, p) - get(a - b, p);
        res = res * qpow(number(p), s);
    }

    // 输出高精度结果（高位在前）
    printf("%d", res.a.back());
    for (int i = res.a.size() - 2; i >= 0; i -- )
        printf("0*%d", WIDTH, res.a[i]);
    
    return 0;
}
```

### 分析
- 时间复杂度：欧拉筛 $O(N)$，质因数分解与高精度乘法的复杂度取决于质数数量和结果位数，适用于 $a \leq 5000$ 左右的情况。
- 能得到组合数的**精确值**，不受模数限制。

## 总结：方法选择指南

不同组合数计算方法的适用场景可归纳为：

| 方法             | 适用场景                   | 核心优势         | 局限性             |
| ---------------- | -------------------------- | ---------------- | ------------------ |
| 递推（杨辉三角） | $a, b \leq 2000$，模数任意 | 实现简单、查询快 | 范围小             |
| 阶乘+逆元        | $a \leq 10^5$，模数为质数  | 范围大、查询快   | 依赖质数模数       |
| 卢卡斯定理       | $a, b$ 极大，模数为小质数  | 支持超大组合数   | 模数必须是质数     |
| 高精度           | 需要精确值，无模数限制     | 结果绝对精确     | 代码复杂、效率一般 |



## 例题

[P3807](https://www.luogu.com.cn/problem/P3807)

[B2164](https://www.luogu.com.cn/problem/B2164)

[B3717](https://www.luogu.com.cn/problem/B3717)

[Acwing-求组合数 IV](https://www.acwing.com/problem/content/890/)



## 推荐的练习

[P1771](https://www.luogu.com.cn/problem/P1771)

[P1350](https://www.luogu.com.cn/problem/P1350)

[P3166](https://www.luogu.com.cn/problem/P3166)
