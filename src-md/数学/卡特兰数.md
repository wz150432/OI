# 卡特兰数详解

在OI（信息学竞赛）中，卡特兰数是一类高频出现的组合数学模型，很多看似无关的计数问题，本质都是卡特兰数的应用。今天就带大家从基础到实战，彻底掌握卡特兰数。



### 什么是卡特兰数？

卡特兰数（Catalan Number）是由比利时数学家欧仁·卡特兰提出的数列，常用于计数“合法路径”“匹配结构”等具有“不跨越某条边界”或“左右对称”约束的问题。  



### 卡特兰数的核心公式

#### 1. 递推公式（最基础，适合小范围计算）

$C_0 = 1, C_{n+1} = \sum_{i=0}^n C_i C_{n-i} (n \geq 0)$  

**推导思路**：将规模为 $n+1$ 的问题拆分为“前 $i$ 个元素”和“后 $n-i$ 个元素”两部分，两部分的合法方案数相乘，再求和所有拆分方式。  

比如 “ $n+1$ 对括号的合法匹配”：第一个左括号必然与某个右括号匹配（设匹配位置为 $2i+1$ ），则左侧有$i$对括号（方案 $C_i$ ），右侧有 $n-i$ 对括号（方案 $C_{n-i}$ ），总和即为 $C_{n+1}$ 。



#### 2. 组合数公式（最常用，适合计算单一项）

$ C_n = \frac{1}{n+1} \binom{2n}{n} $  

**推导思路**：从“不合法方案”反向计算——  

比如“从$(0,0)$到$(n,n)$，只走右（R）和上（U），不穿过对角线$y=x$的路径数”：  

总路径数为$\binom{2n}{n}$（选$n$步走R，其余走U）；  

不合法路径数：任何不合法路径必首次触碰$y=x+1$，将此点之前的U和R交换（U→R，R→U），则终点变为$(n-1, n+1)$，路径数为$\binom{2n}{n-1}$；  

因此合法路径数为$\binom{2n}{n} - \binom{2n}{n-1} = \frac{1}{n+1}\binom{2n}{n}$，即卡特兰数。



#### 3. 生成函数公式（适合推导拓展结论）

卡特兰数的生成函数$G(x) = \sum_{n=0}^\infty C_n x^n$，根据递推公式可推出：  

$ G(x) = 1 + x \cdot G(x)^2 $  

解这个二次方程得：$G(x) = \frac{1 - \sqrt{1 - 4x}}{2x}$（取负号是因为正号会导致发散）。





### OI中的经典应用场景（必刷模型）

掌握“问题→卡特兰数模型”的转化是关键，以下是3类高频题型：



#### 1. 括号/匹配类问题

**例题1**：求$n$对括号的合法匹配方案数（如“()()”“(())”是合法，“)()(”是非法）。  

直接对应卡特兰数$C_n$，用组合数公式计算即可。



**例题2**：求由$n$个1和$n$个-1组成的序列，满足任意前缀和$\geq 0$的序列数。  

转化为“路径问题”：1对应右走（R），-1对应上走（U），前缀和$\geq 0$即不穿过$y=x$，答案为$C_n$。



#### 2. 结构计数类问题

**例题3**：求有$n$个节点的不同二叉搜索树（BST）的数量。  

思路：选一个节点作为根，左子树有$i$个节点（方案$C_i$），右子树有$n-1-i$个节点（方案$C_{n-1-i}$），总和为$C_n$（递推公式的直接应用）。



**例题4**：求$n$个元素的合法出栈序列数（如“1,2进栈，2,1出栈”是合法）。  

转化：设“进栈”为左括号，“出栈”为右括号，合法序列对应合法括号匹配，答案为$C_n$。



#### 3. 路径约束类问题

**例题5**：从$(0,0)$到$(n,n)$，只能走右（R）或上（U），不穿过对角线$y=x$的路径数。  

直接对应组合数公式的推导模型，答案为$C_n$。





### OI中的计算技巧（避坑指南）

卡特兰数增长极快（$C_{20}$已超6.5亿），实际计算需注意两点：**取模**和**高精度**。



#### 1. 取模计算（模数为质数时）

若题目要求对质数$p$取模（如$1e9+7$），直接用组合数公式计算$C_n = \binom{2n}{n} \cdot inv(n+1) \mod p$，其中$inv(x)$是$x$的模逆元。  

步骤：

1. 预处理$1$到$2n$的阶乘$fact[]$（$fact[i] = i! \mod p$）；
2. 预处理阶乘的逆元$inv_fact[]$（$inv_fact[2n] = pow(fact[2n], p-2, p)$，逆推$inv_fact[i] = inv_fact[i+1] \cdot (i+1) \mod p$）；
3. 计算$\binom{2n}{n} = fact[2n] \cdot inv_fact[n] \cdot inv_fact[n] \mod p$；
4. 计算$inv(n+1) = pow(n+1, p-2, p)$；
5. 最终$C_n = \binom{2n}{n} \cdot inv(n+1) \mod p$。



#### 2. 高精度计算（无模数时）

若$n$较大（如$n=100$），卡特兰数会超过64位整数范围，需用高精度加法/乘法（如Python的int自带高精度，C++需手写高精度模板）。  

示例（Python计算$C_n$）：

```python
def catalan(n):

   from math import comb

    return comb(2*n, n) // (n+1)  # 整数除法，避免浮点数误差



print(catalan(10))  # 输出16796
```



### 拓展：卡特兰数的变形问题

OI中常考“卡特兰数的变体”，核心是“调整约束条件，转化为卡特兰数模型”：

\- **变形1**：从$(0,0)$到$(m,n)$（$m > n$），不穿过$y=x$的路径数。  

  答案：$\binom{m+n}{n} - \binom{m+n}{n-1}$（类似原推导，交换后终点变为$(m-1, n+1)$）。

\- **变形2**：$n$对括号，允许嵌套深度不超过$k$的方案数。  

  需用动态规划（$dp[i][j]$表示$i$对括号，深度为$j$的方案数），但当$k \geq n$时退化为卡特兰数。



## 例题





## 推荐的练习