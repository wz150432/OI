# 树链剖分

是一种将整棵树剖分为若干条链，使它组合成线性结构的算法。

树链剖分有很多种，比如重链剖分，长链剖分和 LCT 的剖分。



## 重要概念

重儿子：表示其子结点中子树最大的子结点，如果有多个，任选其一

轻儿子：表示其子结点中不是重儿子的儿子

重边：节点到重子结点的边

轻边：节点到非重子结点的边

重链：若干条重边连成的链



## 重链剖分

根据定义一个结点都属于且仅属于一条重链，且一个重链的起点一定是一个轻儿子。

所有重链把整棵树完全剖分成数个重链，在剖分时 **重边优先遍历**，DFS 的过程中我们会给每个节点一个编号，我们很容易发现一个重链的编号是连续的，且起点的标号是最小的。按 DFN 排序后的序列即为剖分后的链。

因为我们最少是一个二叉树，可以发现，当我们向下经过一条 **轻边** 时，所在子树的大小至少会除以二。因此，对于树上的任意一条路径，把它拆分成从 LCA 分别向两边往下走，分别最多走 $\Theta(logN)$ 次，因此，树上的每条路径都可以被拆分成不超过 $\Theta(logN)$![O(\log n)](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 条重链。

这样在找两个点的 LCA 的时候，我们最多只会走 $logN$ 次。



对于重链剖分的题目我们需要维护的信息。

```cpp
int cnt;
int arr[N], w[N];
int p[N], son[N], id[N];
int d[N], sz[N], top[N];
vector<int> ve[N];
```



先进行第一次 DFS，求出子树大小，父亲，重儿子，深度等信息。

```cpp
void dfs1(int u, int father, int depth) {
    sz[u] = 1, p[u] = father, d[u] = depth;
    for (auto v : ve[u]) {
        if (v == father) continue;
        dfs1(v, u, depth + 1);
        sz[u] += sz[v];
        if (sz[v] > sz[son[u]]) son[u] = v;
    }
}
```



进行第二次 DFS，先遍历重边，赋予每个节点编号，并且某个节点所在重链的起点。

```cpp
void dfs2(int u, int t) {
    id[u] = ++ cnt, top[u] = t, w[cnt] = arr[u];
    if (!son[u]) return ;
    dfs2(son[u], t);
    for (auto v : ve[u]) {
        if (v == son[u] || v == p[u]) continue;
        dfs2(v, v);
    }
}
```



当他们不是一个重链的时候，先让深度较大的往上走，直到他们相遇，在中间我们可以通过对一个重链进行修改或者查询来实现对于 $u$ 之间的 $v$ 路径进行操作，因为一个重链是有序的。

```cpp
void update(int u, int v) {
    while (top[u] != top[v]) {
        if (d[top[u]] < d[top[v]]) swap(u, v);
        u = p[top[u]];
    }
    if (d[u] < d[v]) swap(u, v);
}
```



