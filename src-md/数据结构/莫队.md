# 莫队

一种基于分块的暴力算法，常常用来处理离线区间查询问题。

## 普通莫队

把整个数列分成 $n \over b$ 块，每块的长度为 $b$，比如我们查询区间的 $[l, r]$，我们按照 $l$ 所在的块的编号排序，如果是一个块内的，块的编号为奇数的 $r$ 上升，编号为偶数反之。这样的就优化是防止跨区的时候进行折返。普通莫队的块长一般取 $\sqrt{n ^ 2 \over m}$

```cpp
struct node {
    int l, r, id, t;
    bool operator<(const node& x) const {
        if (l / len != x.l / len) return l < x.l;
        if ((l / len) & 1) return r < x.r;
        return x.r < r;
    }
}Q[N];
```



## 带修莫队

带修莫队处理在某些时间，对区间进行某些操作的区间查询问题。他相比于普通莫队还多出了一个时间轴，$l, r$ 都按照块的编号排序，时间使用同样奇偶优化。其他和普通莫队是一样的，对于时间我们只需要暴力的对时间进行操作即可，因为每次修改影响一个值，所以是 $\Theta(1)$ 的，注意一个技巧就是我们在修改的时候交换一下存数列的值和修改数组的值。块长为 $\sqrt[3]{n  q}$

```cpp
void update(int x, int l, int r) {
    if (l <= M[x].x && M[x].x <= r) {
        del(arr[M[x].x]);
        add(M[x].y);
    }
    swap(arr[M[x].x], M[x].y);
}
```



## 回滚莫队

回滚莫队也叫做不删除或者只删除莫队，我们有时候很难删除一个东西，或者增加一个东西，比如区间最大值或者 Mex。块长一般取 $\sqrt{n}$ 

## 树上莫队

就是先通过把树上问题转换成区间问题来进行操作的莫队。



## 二次离线莫队

