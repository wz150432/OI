# 树状数组

树状数组是一个特别好写的数据结构，但是他可以替代线段树写一些不那么复杂的区间操作。



![](C:/Users/%E6%B1%AA%E6%B4%B2william/OneDrive/Pictures/B%E7%AB%99%E5%B0%81%E9%9D%A2/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-12-01%20160652.png)



树状数组储存的是 $[k - \mathrm{lowbit}(k) + 1, k]$ 这个区间的元素和，也就是结尾为第 $k$ 个元素，长度为 $\mathrm{lowbit}(k)$ 的区间和。

树状数组的最重要的性质：

$\forall x < y < x + \mathrm{lowbit}(k)$， $tr_y$ 不包含 $x$

证明：

对任意 $y\in(x,x+2^k)$，$y=x+t\ (1≤t<2^k)$ 。由于 $t<2^k$，$\mathrm{lowbit}(t)\le2^{k−1}$， 因此

$\mathrm{lowbit}(y)=\mathrm{lowbit}(x+t)=\mathrm{lowbit}(t)≤2^{k−1}$

进而区间左端点 $l(y)=y−\mathrm{lowbit}(y)+1=(x+t)−\mathrm{lowbit}(t)+1$

由于 $t\ge 1$ 且 $\mathrm{lowbit}(t)\le 2^{k−1}$，故 $l(y)\ge (x+1)−2^{k−1} +1=x+2−2^{k−1}$

又因 $\mathrm{lowbit}(x)=2^k⟹x\ge 2^k$，因此：$x+2−2^{k−1}\ge 2^k+2−2^{k−1}=2^{k−1}+2>x$

即 $l(y)>x$，故 $x\notin [l(y),y]$。



lowbit 就是一个数字在二进制表示下第一个 $1$ 和后面的所有 $0$ 表示的数组。比如 `1001000` 他的 lowbit 就是 `1000`。

```cpp
int lowbit(int x) {
    return x & (-x);
}
```



### 修改：

单点修改我们就可以利用刚才证明的性质。首先我们很容易修改第 $x$ 个数字只会影响到小标大等于 $x$ 的树状数组。下一个包含 $x$ 的位置的下标一定是 $x + \mathrm{lowbit}(x)$，我们最多会跳 $logN$ 的区间。因此修改一个值的复杂度就是 $\Theta(logN)$ 。

```cpp
void add(int k, int c) {
    for (int i = k; i < N; i += lowbit(i))
        tr[i] += c;
}
```



### 求前缀和：

因为我们可以用 $logN$ 个 $2$ 的幂次表示出数字 $N$，所以我们可以在 $\Theta(logN)$ 时间复杂度内求出 $1\sim k$ 的前缀和。

```cpp
int query(int k) {
    int res = 0;
    for (int i = k; i ; i -= lowbit(i)) 
        res += tr[i];
    return res;
}
```



我们很容易利用差分拓展到区间修改，单点查询。

同样也可以写出区间修改，区间查询。





