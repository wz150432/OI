# 高精度算法

在日常编程中，我们常用的`int`（32 位，最大约 2e9）、`long long`（64 位，最大约 9e18）能处理的数字范围有限。但当遇到需要计算**超大数**（比如 100 位、1000 位的整数）时，普通数据类型就会 “力不从心”—— 这时候就需要「高精度算法」登场。

高精度算法的核心思想是：**用数组 / 动态数组（vector）模拟数字的存储和手工运算过程**，把超大数拆分成若干个小片段（比如每 1 位、每 4 位）存储，再逐段模拟加减乘除的手工计算逻辑。

本文将基于一份完整的 C++ 高精度代码，从基础存储到加减乘除，再到除法中的 “倍增优化”，一步步拆解高精度算法的实现细节。

## 一、高精度数的基础设计：存储与核心工具

首先看代码中 `number` 结构体的核心设计，这是整个高精度算法的基石。

### 1.1 核心常量：BASE 与 WIDTH

```cpp
const int BASE = 10;    // 基数：每段数字的“进制”
const int WIDTH = 1;    // 每段存储的数字位数
```

- **WIDTH**：定义动态数组中每个元素存储几位数字。比如`WIDTH = 1`时，每个元素存 1 位（$0\sim 9$）；`WIDTH = 4`时，每个元素存 4 位（$0\sim9999$），此时 `BASE` 需设为 `10000`。
- **BASE**：等于`10^WIDTH`，是每段数字的 “进位阈值”。比如`WIDTH = 1`时`BASE = 10`，符合十进制的进位规则。

**为什么要分段？** 当数字极长时（比如 1e4 位），`WIDTH = 4`能让动态数组长度从 1e4 缩减到 2500，减少循环次数，提升效率。本文代码用`WIDTH =  1`是为了简化理解，原理可直接迁移到更大的`WIDTH`。

### 1.2 存储方式：逆序动态数组

```cpp
struct number {
    vector<int> a;  // 逆序存储数字：a[0]是个位，a[1]是十位，a[2]是百位...
    // ... 构造函数、方法 ...
};
```

**关键设计：逆序存储**
手工计算时，加减乘除都从**最低位（个位）** 开始，逆序存储能让最低位位于动态数组的起始位置（`a[0]`），无需反转数据就能直接循环处理，极大简化代码。

例如：数字`123`在动态数组中存储为 `a = [3, 2, 1]`（`a[0]=3`个位，`a[1]=2`十位，`a[2]=1`百位）。

### 1.3 基础操作：构造、输入、输出、比较

#### （1）构造函数：初始化高精度数

```cpp
// 默认构造：初始化为0（动态数组存[0]）
number() : a(1, 0) {}

// 从int构造：将普通整数拆分为逆序动态数组
number(int x) {
    while (x) {
        a.push_back(x % BASE);  // 取最低位（如x=123，先取3，再取2，最后取1）
        x /= BASE;
    }
}
```

#### （2）输入函数：读取字符串转逆序动态数组

```cpp
number read() {
    string s;
    cin >> s;  // 用字符串读取超大数（避免溢出）
    a.clear();
    int extra = s.size() % WIDTH;  // 前面不足WIDTH位的部分（如s=12345，WIDTH=2，extra=1）

    // 1. 处理后面完整的WIDTH位片段（从后往前取）
    for (int i = s.size() - 1; i >= extra; i -= WIDTH) {
        int x = 0;
        // 从i-WIDTH+1到i，拼接成一个数字（如s=12345，i=4时取45，i=2时取23）
        for (int j = WIDTH - 1; j >= 0; j -- )
            x = x * 10 + s[i - j] - '0';
        a.push_back(x);
    }

    // 2. 处理前面不足WIDTH位的片段（如s=12345，extra=1，取第0位的1）
    int x = 0;
        for (int i = 0; i < extra; i ++ )
            x = x * 10 + s[i] - '0';
    if (x) a.push_back(x);

    return *this;
}
```

示例：输入`1234`（`WIDTH=1`），处理过程：

- `extra =  4 % 1  =  0`，循环从`i = 3`（字符 '4'）开始，每次取 1 位，依次 push 4、3、2、1，动态数组最终为`[4,3,2,1]`。

#### （3）输出函数：逆序动态数组转正常数字

```cpp
void print() const {
    // 动态数组最后一个元素是最高位（如a=[4,3,2,1]，最高位是1）
    printf("%d", a.back());
    // 从次高位到最低位，补前导零（确保WIDTH位一致）
    for (int i = a.size() - 2; i >= 0; i -- )
        printf("%0*d", WIDTH, a[i]);  // %0*d：不足WIDTH位补0
    putchar('\n');
}
```

示例：动态数组`[4,3,2,1]`输出时，先打印`a.back() = 1`，再依次打印`2`、`3`、`4`，最终输出`1234`。

#### （4）比较运算符：判断大小（支撑加减除逻辑）

高精度运算中，减法需要 “被减数≥减数”，除法需要 “被除数≥除数”，因此必须先实现比较：

```cpp
// 等于：长度相同且每一位都相同
bool operator==(const number& x) const {
    if (a.size() != x.a.size()) return false;
    for (int i = 0; i < a.size(); i ++ )
        if (a[i] != x.a[i]) return false;
    return true;
}

// 小于：先比长度（短的小），长度相同则从最高位（动态数组末尾）往低位比
bool operator<(const number& x) const {
    if (a.size() != x.a.size()) return a.size() < x.a.size();
    for (int i = a.size() - 1; i >= 0; i -- )
        if (a[i] != x.a[i]) return a[i] < x.a[i];
    return false;  // 所有位相同，不小于
}

// 小于等于：复用<和==
bool operator<=(const number& x) const {
    return *this < x || *this == x;
}
```

示例：比较`123`（`[3,2,1]`）和`45`（`[5,4]`）：

- `123`的动态数组长度是 3，`45`是 2 → `45 < 123`。

## 二、高精度加法：模拟手工进位

加法的核心逻辑：**逐位相加 + 处理进位**，与手工计算完全一致。

### 2.1 加法原理

1. 从最低位（`a[0]`）开始，将两个数的对应位相加，再加上上一位的进位；
2. 当前位结果 = 总和 % BASE（取余留位）；
3. 新进位 = 总和 / BASE（取商进位）；
4. 处理最后一位的进位（若有），并删除动态数组末尾的无效 0（如结果为`100`，动态数组存`[0,0,1]`，无需保留多余的 0）。

### 2.2 代码解析

```cpp
number operator+(const number& x) const {
    number res;          // 结果
    res.a.clear();       // 清空默认的0
    int carry = 0;       // 进位，初始为0
    // 循环条件：处理完所有位，且进位不为0（避免最后一位有进位没处理）
    for (int i = 0; i < a.size() || i < x.a.size() || carry; i ++ ) {
        // 累加当前位：当前数的第i位（若存在） + 另一个数的第i位（若存在） + 进位
        if (i < a.size()) carry += a[i];
        if (i < x.a.size()) carry += x.a[i];
        // 当前位结果：取余留位
        res.a.push_back(carry % BASE);
        // 更新进位：取商进位
        carry /= BASE;
    }
    
    return res;
}
```

### 2.3 示例：计算 123 + 456

- 数 A（123）的动态数组：`a = [3, 2, 1]`

- 数 B（456）的动态数组：`x.a = [6, 5, 4]`

- 运算过程：

  | 位数（i） | A[i] | B[i] | 累加 + 进位 | 当前位结果（%10） | 新进位（/10） |
  | --------- | ---- | ---- | ----------- | ----------------- | ------------- |
  | 0（个位） | 3    | 6    | 3+6+0=9     | 9                 | 0             |
  | 1（十位） | 2    | 5    | 2+5+0=7     | 7                 | 0             |
  | 2（百位） | 1    | 4    | 1+4+0=5     | 5                 | 0             |
  | 3（进位） | -    | -    | 0           | -                 | 0             |

- 结果动态数组：`[9,7,5]`，输出为`579`（正确）。

## 三、高精度减法：模拟手工借位

减法的核心逻辑：**逐位相减 + 处理借位**，需确保被减数 ≥ 减数（代码中由调用者保证，如除法中先判断大小）。

### 3.1 减法原理

1. 从最低位开始，用被减数的当前位减去减数的当前位，再减去上一位的借位；
2. 若结果为负，需向高位借位（当前位 + BASE，借位设为 1）；
3. 若结果非负，借位设为 0；
4. 删除动态数组末尾的无效 0（如结果为`0`，动态数组存`[0]`，避免存`[0,0]`）。

### 3.2 代码解析

注意这里默认减法的结果为非负整数，你需要在减之前比较一下大小

```cpp
number operator-(const number& x) const {
    number res;
    res.a.clear();
    int borrow = 0;      // 借位，初始为0
    // 循环条件：处理完被减数和减数的所有位
    for (int i = 0; i < a.size() || i < x.a.size(); i ++ ) {
        // 被减数当前位（若存在），减去借位
        int sub = (i < a.size() ? a[i] : 0) - borrow;
        // 减去减数当前位（若存在）
        if (i < x.a.size()) sub -= x.a[i];
        // 处理借位：若sub为负，加BASE补位，借位设1；否则借位设0
        if (sub < 0) {
            sub += BASE;
            borrow = 1;
        } 
        else borrow = 0;
        res.a.push_back(sub);
    }
    // 删除末尾的无效0（如结果为100-50=50，动态数组为[0,5]，无需保留前面的0）
    while (res.a.size() > 1 && !res.a.back())
        res.a.pop_back();
    
    return res;
}
```

### 3.3 示例：计算 321 - 123

- 数 A（321）的动态数组：`a = [1, 2, 3]`

- 数 B（123）的动态数组：`x.a = [3, 2, 1]`

- 运算过程：

  | 位数（i） | A[i] | B[i] | 初始 sub（A [i]- 借位） | 减 B [i] 后 sub | 补位（sub<0） | 借位 | 当前位结果 |
  | --------- | ---- | ---- | ----------------------- | --------------- | ------------- | ---- | ---------- |
  | 0（个位） | 1    | 3    | 1 - 0 = 1               | 1-3=-2          | +10→8         | 1    | 8          |
  | 1（十位） | 2    | 2    | 2 - 1 = 1               | 1-2=-1          | +10→9         | 1    | 9          |
  | 2（百位） | 3    | 1    | 3 - 1 = 2               | 2-1=1           | 无需          | 0    | 1          |

- 结果动态数组：`[8,9,1]`，输出为`198`（正确）。

## 四、高精度乘法：逐位相乘再累加

乘法的核心逻辑：**逐位相乘 + 错位累加 + 处理进位**，模拟手工乘法中 “每一位乘完后错位相加” 的过程。

### 4.1 乘法原理

1. 被乘数的第`i`位（对应`10^i`）与乘数的第`j`位（对应`10^j`）相乘，结果对应`10^(i + j)`，因此存入结果的第`i + j`位；
2. 逐位计算所有乘积并累加到结果的对应位，最后处理每一位的进位；
3. 删除末尾的无效 0。

### 4.2 代码解析

```cpp
number operator*(const number& x) const {
    number res;
    // 结果的最大长度 = 被乘数长度 + 乘数长度（如99*99=9801，2位+2位=4位）
    res.a.resize(a.size() + x.a.size(), 0);
    int carry = 0;
    for (int i = 0; i < a.size(); i ++ ) {  // 遍历被乘数的每一位
        carry = 0;
        for (int j = 0; j < x.a.size() || carry; j ++ ) {  // 遍历乘数的每一位 + 处理进位
            // 累加：当前结果位 + 被乘数第i位 * 乘数第j位（若存在） + 进位
            int sum = res.a[i + j] + carry;
            if (j < x.a.size()) sum += a[i] * x.a[j];
            // 当前位结果：取余留位
            res.a[i + j] = sum % BASE;
            // 更新进位：取商进位
            carry = sum / BASE;
        }
    }

    // 删除末尾的无效0（如20*30=600，动态数组为[0,0,6]，无需保留前面的0）
    while (res.a.size() > 1 && !res.a.back())
        res.a.pop_back();
    return res;
}
```

**注意**：当你选择的`BASE` 较大的时候请使用`long long`存储`sum`，避免`a[i] * x.a[j]`超过 int 范围导致溢出。

### 4.3 示例：计算 12 * 34

- 数 A（12）的动态数组：`a = [2, 1]`
- 数 B（34）的动态数组：`x.a = [4, 3]`
- 运算过程：
  1. 被乘数第 0 位（2）× 乘数第 0 位（4）=8 → 存入`res[0]`，进位 0；
  2. 被乘数第 0 位（2）× 乘数第 1 位（3）=6 → 存入`res[1]`，进位 0；
  3. 被乘数第 1 位（1）× 乘数第 0 位（4）=4 → 累加`res[1]`（6+4=10），`res[1]`=0，进位 1；
  4. 被乘数第 1 位（1）× 乘数第 1 位（3）=3 → 累加`res[2]`（0+3+1=4），`res[2]`=4，进位 0；
- 结果动态数组：`[8,0,4]`，输出为`408`（正确）。

## 五、高精度除法：倍增优化试商

除法是高精度运算中最复杂的，核心难点是 “试商”—— 如何快速找到最大的`k`，使得`k × 除数 ≤ 被除数`。普通逐位试商效率极低，因此引入**倍增试商**优化。

### 5.1 为什么需要倍增？

若被除数是 1e100，除数是 1，普通试商需要循环 1e100 次才能得到商，完全不可行。而倍增通过 “每次将`k`和`除数`翻倍”，快速逼近最大`k`，循环次数从`O(被除数)`降至`O(log 被除数)`，效率指数级提升。

### 5.2 倍增除法原理

1. 初始化：`d = 被除数`（待减的余数）、`q = 0`（商）、`k = 1`（当前试商的系数）、`p = 除数`（当前的倍增除数）；
2. 倍增试商：不断将 `p` 和 `k` 翻倍（`p = p + p`，`k = k + k`），直到`2 * p > d`，此时 `k` 是当前能加的最大系数；
3. 更新结果：将 `k` 加到商 `q` 中，用 `d` 减去 `p` （更新余数）；
4. 重置`k = 1`和 `p = 除数`，重复步骤 2 - 3，直到 `d < 除数`（余数小于除数，除法结束）。

### 5.3 代码解析

```cpp
number operator/(const number& x) const {
    if (*this < x) return number(0);  // 被除数 < 除数，商为0

    number d = *this;  // 余数：初始为被除数
    number q(0);       // 商：初始为0
    number k(1);       // 倍增系数：初始为1
    number p = x;      // 倍增除数：初始为除数

    while (!(d < x)) {  // 只要余数 ≥ 除数，就继续试商
        // 第一步：倍增p和k，直到p*2 > d（找到当前最大的k）
        while (true) {
            number p1 = p + p;  // p1 = p * 2
            number k1 = k + k;  // k1 = k * 2
            if (p1 <= d) {      // 若p*2 ≤ d，继续倍增
                p = p1;
                k = k1;
            } else {
                break;  // 否则停止倍增，当前k是最大有效系数
            }
        }

        // 第二步：更新商和余数
        q = q + k;  // 商加上当前k
        d = d - p;  // 余数减去当前p

        // 第三步：重置k和p，准备下一轮试商
        k = number(1);
        p = x;
    }

    return q;  // 返回商（余数d可根据需求返回）
}
```

### 5.4 示例：计算 123 ÷ 5

- 被除数`123`（`[3,2,1]`），除数`5`（`[5]`）；
- 运算过程：
  1. 初始：`d = 123`，`q = 0`，`k = 1`，`p = 5`；
  2. 倍增试商：
     - `p1 = 10`（5+5），`k1 = 2` → 10 ≤ 123 → `p = 10`，`k = 2`；
     - `p1 = 20`（10+10），`k1 = 4` → 20 ≤ 123 → `p = 20`，`k = 4`；
     - `p1 = 40`，`k1 = 8` → 40 ≤ 123 → `p = 40`，`k = 8`；
     - `p1 = 80`，`k1 = 16` → 80 ≤ 123 → `p = 80`，`k = 16`；
     - `p1 = 160` → 160 > 123 → 停止倍增；
  3. 更新：`q = 0 + 16 = 16`，`d = 123 - 80 = 43`；
  4. 重置 `k = 1，p = 5`，再次试商：
     - 倍增至`p = 40`（`k = 8`），`p1 = 80 > 43` → 停止；
     - 更新：`q = 16 + 8 = 24`，`d = 43 - 40 = 3`；
  5. 重置 `k = 1`，`p = 5` → `d = 3 < 5` → 循环结束；
- 最终商`q = 4`（正确），余数`d = 3`。

## 六、优化建议

1. **调整 WIDTH 和 BASE**：将`WIDTH = 4`，`BASE = 10000`，减少动态数组长度，提升运算速度；
2. **处理负数**：当前代码仅支持非负整数，可增加符号位（如`bool sign`），扩展为支持负数运算；
3. **余数返回**：除法函数可返回 `pair <number, number>`（商和余数），满足更多场景需求；
4. **避免冗余计算**：如加法中`res`的初始化可直接分配足够空间，减少 `push_back` 的开销。

## 七、总结

高精度算法的本质是 “用代码模拟手工计算”，核心步骤可归纳为：

1. **存储**：逆序动态数组分段存储，适配手工运算的低位优先逻辑；
2. **基础**：实现输入、输出、比较，为运算提供支撑；
3. **运算**：
   - 加法 / 减法：逐位处理 + 进位 / 借位；
   - 乘法：逐位相乘 + 错位累加 + 进位；
   - 除法：倍增试商优化，快速找到最大有效系数。