### KMP

一个初学者必学的字符串匹配算法，初学学习有可能难以理解，但是我认为可能是博客写的不太清楚。我们想要知道一个长度为 $n$ 的字符串 $s1$ 和长度为 $m$ 的字符串 $s2$，问一个字符串内有几个子串等于另一个字符串，给出起始位置。

我们很容易想到暴力的 $O(N^2)$ 的算法，但是太慢了，KMP 可以让我们在 $O(N + M)$ 的时间内算出结果。首先我们需要注意一个非常重要的东西，也是我们实现算法的关键 —— $ne$ 数组，$ne_i$ 表示区间 $[1, i]$ 中前缀等于后缀的最长长度（当然不能完全重合，不然就是区间长度了）。首先来经典的假设，假设我们已经知道了 $\forall x \in[1, i - 1]$ 的 $ne_x$ 都是已知的，怎么求出 $ne_i$。

我们很容易发现我们匹配长度每次最多增加一，也就是当我们匹配的时候如果 $s_i \neq s_{ne_{i-1}+1}$ 我们直接跳到匹配 $s_{ne_{ne_{i-1}} +1}$。为什么这区间都不可能呢，很简单，根据定义我们知道区间 $1 \sim ne_{i - 1}$ 和 $i - ne_{i-1} \sim i - 1$ 是等价的，所以后面后缀的区间也同样可以使用前面计算出的 $ne$ 函数，而如果在这两个区间内还有值使得 $ne_i$，说明我们之前算的值不是最大显然矛盾。

时间复杂度证明的话就比较麻烦了，具体的证明我是不会的，但是有一个比较好理解的讲法。我们看失配指针 $j$ 最多增加 $len$ 次，因为我们每次循环最多比上次多匹配一个，也就是说他最多也就减少 $len$ 次。所以就是 $O(N + M)$ 级别的。



```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e6 + 10;

int n, m;
int ne[N];
string s1, s2;

int main() {
    cin >> s1 >> s2;
    n = s1.size(), m = s2.size();
    s1 = " " + s1, s2 = " " + s2;
    for (int i = 2, j = 0; i <= m; ++ i) {
        while (j && s2[i] != s2[j + 1]) j = ne[j];
        if (s2[i] == s2[j + 1]) j ++ ;
        ne[i] = j;
    }
    
    for (int i = 1, j = 0; i <= n; ++ i) {
        while (j && s1[i] != s2[j + 1]) j = ne[j];
        if (s1[i] == s2[j + 1]) j ++ ;
        if (j == m) {
            cout << i - j + 1 << endl;
            j = ne[j];
        }
    }

    return 0;
}
```

