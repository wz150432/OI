# 稀疏表（Sparse Table）：通过 O(1) 查询实现高效区间查询

在竞争性编程中，我们经常需要高效地回答区间查询（例如“这个区间内的最大值是多少？”）。虽然线段树和树状数组很流行，但 **稀疏表**（Sparse Table）数据结构因其简洁性和速度而脱颖而出——它在 $O(n \log n)$ 的预处理时间后，能够提供 $O(1)$ 的查询时间。

让我们深入了解稀疏表的工作原理、实现方法，以及为什么它适用于静态数组（初始化后不再更改的数组）。

## 什么是稀疏表？

稀疏表是一个预先计算好的表格，允许我们在常数时间内回答区间查询（例如区间最大值、最小值或最大公约数）。它的核心思想是**预先计算长度为 $2^j$ 的区间的答案**，并通过组合这些预先计算的结果来回答任意的区间查询。

### 核心思想：

对于任意区间 $[l, r]$，我们可以找到最大的 $k$，使得 $2^k \leq (r - l + 1)$。那么，区间 $[l, r]$ 可以被两个长度为 $2^k$ 的重叠区间覆盖：

- 一个起始于 $l$（覆盖 $[l, l + 2^k - 1]$）
- 一个结束于 $r$（覆盖 $[r - 2^k + 1, r]$）

区间 $[l, r]$ 的答案就是这两个区间预先计算答案的组合（例如取最大值、最小值）。

## 如何构建稀疏表

我们以**区间最值查询（RMQ）**  中的最大值为例。其步骤可以推广到其他幂等操作（多次应用不会改变结果的操作，如最大公约数等）。

### 1. 预处理：构建表格

我们定义一个二维数组 $f[i][j]$，其中：

- $i$ 是区间的起始索引。
- $j$ 表示区间的长度为 $2^j$。

因此，$f[i][j]$ 存储了区间 $[i, i + 2^j - 1]$ 中的最大值。

#### 递推关系：

- 对于 $j = 0$（区间长度 $2^0 = 1$）：$f[i][0] = a[i]$（元素本身的值）。
- 对于 $j > 0$：将区间 $[i, i + 2^j - 1]$ 分成两个长度为 $2^{j-1}$ 的区间：
  $
  f[i][j] = \max\left(f[i][j-1],\ f\left[i + 2^{j-1}\right][j-1]\right)
  $

### 2. 查询：回答区间最大值查询

要查找 $[l, r]$ 中的最大值：

1. 计算 $k = \lfloor \log_2(r - l + 1) \rfloor$（能够容纳在区间长度内的最大的 2 的幂）。
2. 结果是两个重叠区间的最大值：
   $
   \max\left(f[l][k],\ f\left[r - 2^k + 1\right][k]\right)
   $

## 完整实现（C++）

以下是区间最大值查询的完整稀疏表实现：

```cpp
#include <iostream>
#include <cmath> // 需要包含cmath库以使用log函数

using namespace std;

const int N = 2e5 + 10, M = 20;

int n, q;
int a[N];
int f[N][M];

int RMQ(int l, int r) {
    int k = floor(log(r - l + 1) / log(2));
    return max(f[l][k], f[r - (1 << k) + 1][k]);
}

int main() {
    cin >> n;

    for (int i = 1; i <= n; i ++ ) cin >> a[i];

    int k_val = floor(log(n) / log(2)); // 重命名以避免冲突
    for (int j = 0 ; j <= k_val; j ++ )
        for (int i = 1; i + (1 << j) - 1 <= n; i ++ ) {
            if (!j) f[i][j] = a[i];
            else f[i][j] = max(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);
        }

    cin >> q;

    while (q -- ) {
        int l, r;
        cin >> l >> r;
        cout << RMQ(l, r) << endl;
    }

    return 0;
}
```

## 时间复杂度分析

- **预处理**：$O(n \log n)$。我们填充了一个大小为 $n \times \log n$ 的表格，每个条目的计算时间为 $O(1)$。
- **查询**：$O(1)$。每个查询组合两个预先计算好的区间，只需要常数时间。

## 何时使用稀疏表

稀疏表在以下场景中表现出色：

- 数组是**静态的**（初始化后没有更新）。对于动态数组，它的效率不高（应使用线段树）。
- 查询是**幂等的**（例如最大值、最小值、最大公约数、最小公倍数）。对于非幂等操作（例如求和），重叠的区间会导致不正确的结果。
- 你需要**快速的查询时间** $O(1)$，并且可以承受 $O(n \log n)$ 的预处理时间。

## 与其他结构的优势比较

| 结构                  | 预处理时间    | 查询时间    | 支持更新？ |
| --------------------- | ------------- | ----------- | ---------- |
| 稀疏表 (Sparse Table) | $O(n \log n)$ | $O(1)$      | 否         |
| 线段树 (Segment Tree) | $O(n)$        | $O(\log n)$ | 是         |
| 朴素方法 (Naive)      | $O(1)$        | $O(n)$      | 不适用     |

## 示例演练

假设我们有一个数组 $a = [3, 1, 4, 2, 5]$。

1.  **预处理**：
    - $j = 0$（长度 1）：$f[i][0] = a[i] \implies [3, 1, 4, 2, 5]$
    - xxxxxxxxxx76 1#include <iostream>2​3using namespace std;4​5const int N = 1e5 + 10;  // 堆的最大容量（可根据需求调整）6​7template<typename T>8struct Heap {9    int s;          // 堆的当前大小（初始为0）10    T a[N];         // 存储堆元素的数组（1基索引）11​12    // 向下调整节点13    void down(int u) {14        int t = u;  // t追踪当前节点及其子节点中的最大值节点索引15        // 比较左子节点16        if (2 * u <= s && a[2 * u] > a[t]) t = 2 * u;17        // 比较右子节点18        if (2 * u + 1 <= s && a[2 * u + 1] > a[t]) t = 2 * u + 1;19        // 若当前节点不是最大值节点，交换并递归调整20        if (t != u) {21            swap(a[u], a[t]);22            down(t);23        }24    }25​26    // 向上调整节点27    void up(int u) {28        // 当节点有父节点且值大于父节点时，循环向上调整29        while (u > 1 && a[u / 2] < a[u]) {30            swap(a[u / 2], a[u]);31            u /= 2;  // 移动到父节点索引32        }33    }34​35    // 插入元素x36    void push(T x) {37        a[ ++ s] = x;  // 追加到数组末尾38        up(s);       // 向上调整新节点39    }40​41    // 删除堆顶元素（最大值）42    void pop() {43        if (s) {  // 堆非空时操作44            swap(a[1], a[s -- ]);  // 交换根节点与尾节点，缩小堆大小45            down(1);             // 向下调整新根节点46        }47    }48​49    // 获取堆顶元素（最大值）50    T top() {51        return a[1];52    }53};54​55// 定义一个int类型的大根堆56Heap<int> h;57​58int main() {59    int n;60    cin >> n;  // 输入操作次数61​62    while (n -- ) {63        int opt, x;64        cin >> opt;  // 输入操作类型（1：插入，2：删除，其他：查询堆顶）65        if (opt == 1) {66            cin >> x;67            h.push(x);68        } else if (opt == 2) {69            h.pop();70        } else {71            cout << h.top() << endl;72        }73    }74​75    return 0;76}cpp
    - $j = 2$（长度 4）：$f[i][2] = \max(f[i][1], f[i + 2][1]) \implies [4, 5]$ （对于 i=1 和 i=2）

2.  **查询 $[1, 4]$**（值 [3, 1, 4, 2]）：
    - 长度 = 4，所以 $k = \log_2(4) = 2$。
    - 结果 = $\max(f[1][2], f[4 - 4 + 1][2]) = \max(f[1][2], f[1][2]) = 4$。

## 关键要点

- 稀疏表非常适合静态数组和幂等区间查询。
- 预处理需要 $O(n \log n)$ 时间，但查询是 $O(1)$。
- 其核心思想是预先计算长度为 $2^j$ 的区间，并将它们组合起来以回答任意范围的查询。

下次你需要处理静态数组上的区间最大/最小值查询时，可以尝试使用稀疏表——它实现简单且速度极快！
