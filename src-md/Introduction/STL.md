# STL（标准模板库）

STL（标准模板库）的容器是 C++ 高效编程的 “利器”—— 它们封装了常用数据结构的实现，让我们无需重复 “造轮子”，只需根据场景选对 “工具”，就能轻松应对各类数据存储与操作需求。下面为你拆解最核心的 STL 容器，包括命名方式、访问方式等关键信息，帮你快速匹配「场景 ↔ 容器」。

### 一、vector

- **本质**：基于**连续内存**的动态数组（自动扩容，扩容时可能拷贝旧元素）。
- **命名方式**（定义语法）：
  `vector<元素类型> 变量名;`（模板类需指定元素类型）
  示例：`vector<int> nums;`（存储 int 类型的动态数组）、`vector<string> strs;`（存储字符串的动态数组）。
- 访问方式：
  - 随机访问：`[]` 运算符（如 `nums[0]`，无越界检查）、`at(index)` 方法（如 `nums.at(0)`，有越界检查，抛出 `out_of_range` 异常）。
  - 首尾访问：`front()`（返回首元素，如 `nums.front()`）、`back()`（返回尾元素，如 `nums.back()`）。
  - 迭代器访问：`begin()`（首元素迭代器）、`end()`（尾后迭代器），如 `for (auto it = nums.begin(); it != nums.end(); ++it) { *it; }`。
- 核心操作：
  - `push_back(val)` / `pop_back()`：尾部插入 / 删除，均摊时间复杂度 $O(1)$。
  - `resize(n)`：调整数组大小（扩容时需拷贝元素，最坏 $O(n)$ ）。
- **适用场景**：读操作多、需要随机访问的场景（如存储序列、结果集、模拟数组）。

### 二、deque

- **本质**：双端队列（**分段连续内存**，兼顾头尾操作效率）。
- **命名方式**（定义语法）：
  `deque<元素类型> 变量名;`
  示例：`deque<double> dq;`（存储 double 类型的双端队列）。
- 访问方式：
  - 随机访问：`[]` 运算符（如 `dq[2]`）、`at(index)` 方法（如 `dq.at(2)`）。
  - 首尾访问：`front()`（首元素）、`back()`（尾元素）。
  - 迭代器访问：`begin()` / `end()` 遍历（同 vector）。
- 核心操作：
  - `push_back(val)` / `push_front(val)`：头尾插入，时间复杂度 $O(1)$。
  - `pop_back()` / `pop_front()`：头尾删除，时间复杂度 $O(1)$。
- **适用场景**：需频繁在**头尾**操作的场景（如滑动窗口、双端队列模拟）。

### 三、list

- **本质**：双向链表（**非连续内存**，节点间通过指针连接）。
- **命名方式**（定义语法）：
  `list<元素类型> 变量名;`
  示例：`list<char> chars;`（存储 char 类型的双向链表）。
- 访问方式：
  - **不支持随机访问**（无`[]`和`at()`），需通过迭代器或首尾方法：
  - 首尾访问：`front()`（首元素）、`back()`（尾元素）。
  - 迭代器访问：`begin()` / `end()` 遍历（仅支持双向移动，如 `++ it` / `-- it`）。
- 核心操作：
  - `push_back(val)` / `push_front(val)`：头尾插入，时间复杂度 $O(1)$。
  - `insert(pos, val)`：在迭代器`pos`位置插入，时间复杂度 $O(1)$（需先定位`pos`，定位耗时 $O(n)$）。
  - `erase(pos)`：删除`pos`位置元素，时间复杂度 $O(1)$（定位耗时 $O(n)$）。
- **优缺点**：插入 / 删除极快，但**不支持随机访问**（需遍历，时间复杂度 $O(n)$ ）。

### 四、stack

- **本质**：栈（基于 `deque` 实现，遵循「后进先出 LIFO」规则）。
- **命名方式**（定义语法）：
  `stack<元素类型> 变量名;`（默认底层容器为 deque，可指定其他容器）
  示例：`stack<int> st;`（int 类型的栈）、`stack<string, vector<string>> st_vec;`（指定底层用 vector 实现）。
- 访问方式：
  - 仅支持访问栈顶元素：`top()` 方法（如 `st.top()`），**无随机访问**（符合栈的 “只露栈顶” 特性）。
- 核心操作：
  - `push(val)`：栈顶插入元素，时间复杂度 $O(1)$。
  - `pop()`：删除栈顶元素（无返回值），时间复杂度 $O(1)$。
  - `empty()`：判断栈是否为空，`size()`：返回元素个数。
- **适用场景**：需要 “后进先出” 逻辑的场景（如括号匹配、DFS 非递归实现）。

### 五、priority_queue

- **本质**：优先队列（默认**大顶堆**，基于 `vector` 实现堆结构）。

- 命名方式

  （定义语法）：`priority_queue<元素类型, 底层容器类型, 比较规则>` 变量名;（后两个参数可省略，默认`vector`底层 + 大顶堆）

  示例：

  - 大顶堆（默认）：`priority_queue<int> pq;`
  - 小顶堆：`priority_queue<int, vector<int>, greater<int>> min_pq;`

- 访问方式：

  - 仅支持访问优先级最高的元素（堆顶）：`top()` 方法（如 `pq.top()`），**无随机访问**。

- 核心操作：

  - `push(val)`：插入元素（需维护堆结构），时间复杂度 $O(logn)$。
  - `pop()`：删除堆顶元素，时间复杂度 $O(logn)$。

- **特性**：可通过模板参数指定比较规则（如 `greater<int>` 实现小顶堆）。

### 六、map

- **本质**：键值对映射（基于**红黑树**，键自动**升序**排列）。
- **命名方式**（定义语法）：
  `map<键类型, 值类型> 变量名;`（需指定键和值的类型）
  示例：`map<string, int> dict;`（键为 *string*、值为 *int *的映射，如单词→出现次数）。
- 访问方式：
  - `[]` 运算符：`dict["apple"]`（键存在则返回值，不存在则插入默认值）。
  - `at(key)` 方法：`dict.at("apple")`（键不存在时抛出异常，更安全）。
  - 迭代器访问：通过 `begin()` / `end()` 遍历键值对（`it->first` 为键，`it->second` 为值）。
  - `find(key)` 方法：返回键对应的迭代器（如 `auto it = dict.find("apple"); if (it != dict.end()) { it->second; }`）。
- 核心操作：
  - `insert(pair<key, val>)`：插入键值对，时间复杂度 $O(logn)$。
  - `erase(key)`：删除指定键，时间复杂度 $O(logn)$。
- **适用场景**：需要**按键有序存储**的场景（如字典、有序统计）。

### 七、unordered_map

- **本质**：哈希表实现的键值对映射（键**无序**）。
- **命名方式**（定义语法）：
  `unordered_map<键类型, 值类型> 变量名;`
  示例：`unordered_map<int, string> id_to_name;`（键为 *int*、值为 *string* 的哈希映射）。
- **访问方式**：
  与 `map` 完全一致：`[]` 运算符、`at(key)` 方法、迭代器遍历、`find(key)` 查找（用法相同，仅底层实现不同）。
- 核心操作：
  - `insert(pair<key, val>)`：插入键值对（**平均** $O(1)$，哈希冲突时最坏 $O(n)$）。
  - `erase(key)`：删除指定键（**平均** $O(1)$，哈希冲突时最坏 $O(n)$）。
- **优缺点**：**平均效率高于 `map`**，但键无序、内存消耗略大；哈希冲突严重时性能会下降。

### 八、bitset

- **本质**：固定大小的**位集合**（编译期确定位数）。
- **命名方式**（定义语法）：
  `bitset<位数> 变量名;`（位数必须是编译期常量，如 16、32、1024）
  示例：`bitset<32> bs;`（32 位的位集合）、`bitset<100> flags;`（100 位的标志位集合）。
- 访问方式：
  - `[]` 运算符：`bs[0]`（访问第 0 位，返回 *bool* 值）。
  - `test(pos)` 方法：`bs.test(2)`（判断第 2 位是否为 1，返回 *bool*，更安全）。
  - 整体转换：`to_ulong()`（转换为 *unsigned long*）、`to_string()`（转换为二进制字符串）。
- 核心操作：
  - `set(pos)`：设置第`pos`位为 1，`set()`（全部置 1）。
  - `reset(pos)`：设置第`pos`位为 0，`reset()`（全部置 0）。
  - `flip(pos)`：翻转第`pos`位，`flip()`（全部翻转）。
  - `count()`：统计 1 的个数，时间复杂度 $O(\frac{n}{64})$（$n$ 为总位数）。
- **优点**：空间效率极高（1 字节存 8 位），适合**位运算场景**（如状态压缩、位图标记）。