# 0 - 1背包问题

## 1. 问题定义

给定两个数组：

- `volume[]`：存储每个物品的体积（例如`[0, 2, 3, 4, 5]`）
- `values[]`：存储每个对应物品的价值（例如`[0, 3, 4, 5, 6]`）
- 一个容量为`m`的背包（例如`8`）

**目标**：选择一个物品子集，使得它们的总体积不超过`m`，且总价值最大化

## 2. 动态规划(DP)方法

暴力方法（检查所有子集）具有指数时间复杂度 $O(2 ^ n)$ ，对于大的 $n$ 不可行。动态规划通过存储中间结果来避免冗余计算，从而优化此过程。

### 2.1 状态转移

`dp[i][j]` 等于使用前 `i` 个物品和背包容量 `j` 可实现的最大价值

对于每个物品 `i`（从 1 到 `n`）和每个可能容量 `j`（从1到 `m`）：

1. **排除物品 `i` **：`dp[i][j] = dp[i - 1][j]`（价值与不使用物品`i`时相同）
2. **包含物品 `i` **：如果 `volume[i] ≤ j`（物品能放下），`dp[i][j] = values[i] + dp[i - 1][j - volume[i]]`（将物品`i`的价值加到剩余容量的最佳价值上）

递推关系为：

```cpp
if (volume[i] ≤ j)
	dp[i][j] = max(dp[i - 1][j], values[i] + dp[i - 1][j - volume[i]])

if (volume[i] > j)
	dp[i][j] = dp[i - 1][j]
```

## 3. 示例演练

使用以下数据：

- `volume = [0, 2, 3, 4, 5]`
- `values = [0, 3, 4, 5, 6]`
- `m = 8`

### 步骤1：初始化DP表

| 物品(i) \ 容量(j)         | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |
| ------------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0 (无物品)                | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| 1 (volume = 2, value = 3) | 0    | 0    | 3    | 3    | 3    | 3    | 3    | 3    | 3    |
| 2 (volume = 3, value = 4) | 0    | 0    | 3    | 4    | 4    | 7    | 7    | 7    | 7    |
| 3 (volume = 4, value = 5) | 0    | 0    | 3    | 4    | 5    | 7    | 8    | 9    | 9    |
| 4 (volume = 5, value = 6) | 0    | 0    | 3    | 4    | 5    | 7    | 8    | 9    | 10   |

### 步骤2：最终结果

`dp[4][8] = 10` → 最大价值为10（通过选择体积为 3 和 5、价值为 4 和 6 的物品实现）

## 4. 代码实现(C++)

```cpp
#include <iostream>

using namespace std;

const int N = 1010;

int n, m; // n是物品数量，m是背包容量
int v[N], w[N]; // v = 价值, w = 体积
int f[N][N];

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i ++ ) cin >> v[i] >> w[i];
    
    for (int i = 1; i <= n; i ++ )
        for (int j = 0; j <= m;  j ++ ) {
            f[i][j] = f[i - 1][j];
            if (j >= w[i]) 
                f[i][j] = max(f[i - 1][j], f[i - 1][j - w[i]] + v[i]);
        }
                
    cout << f[n][m];
    
    return 0;
}
```

## 5. 空间优化

二维数组可以优化为一维，因为每一行`i`只依赖于前一行`i - 1`。优化后的代码：

```cpp 
#include <iostream>

using namespace std;

const int N = 1010;

int n, m;
int f[N];

int main() {
    cin >> n >> m;

    for (int i = 1; i <= n; i ++ ) {
        int v, w;
        cin >> v >> w;
        for (int j = m ; j >= w; j -- )
            f[j] = max(f[j], f[j - w] + v);
    }

    cout << f[m];

    return 0;
}
```

### 空间复杂度

- 二维版本：`O(n * m)`
- 一维版本：`O(m)`（对于大的 `n` 有显著改进）