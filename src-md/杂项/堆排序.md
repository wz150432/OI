# 堆排序

  堆排序依赖于**堆**，通过不断把堆维护的极值（堆顶）扔到最后完成排序。

```cpp
void down(int u) {
    int t = u;
    if (2 * u <= s && a[t] < a[2 * u]) t = 2 * u;
    if (2 * u + 1 <= s && a[t] < a[2 * u + 1]) t = 2 * u + 1;
    if (t != u) {
        swap(a[t], a[u]);
        down(t);
    }
}
```



因为堆是二叉树，所以我们从 $\lfloor \frac{n}{2} \rfloor $ 开始 down 一定可以维护好堆顶信息

```cpp
for (int i = n / 2; i ; i -- ) down(i);
while (s) {
    down(1);
    swap(a[1], a[s -- ]);
}
```

