# 位运算

位运算作为 OI 中高效的工具，其核心是对二进制位的直接操作。本文将从最基础的运算符讲起，逐步过渡到二进制枚举的实战应用，帮助初学者快速掌握这一重要技能。

## 一、位运算基础：五大核心运算符

计算机中所有数据都以二进制形式存储（$0$ 和 $1$ 组成的序列）。位运算就是直接对这些二进制位进行操作，由于跳过了十进制转换，运算速度远快于普通算术运算。

### 1. 按位与（&）

**规则**：两个二进制位都为 $1$ 时，结果为 $1$；否则为 $0$。

**示例**：计算 $5 \& 3$
- $5$ 的二进制：$101$
- $3$ 的二进制：$011$
- 运算结果：$001$（对应十进制 $1$）

**用途**：提取某一位（如 $x \& 1$ 判断奇偶，结果为 $1$ 则是奇数）、清除某些位（如 $x \& \sim(1<<k)$ 将第 $k$ 位设为 0）。

### 2. 按位或（|）

**规则**：两个二进制位只要有一个为 $1$，结果为 $1$；否则为 $0$。

**示例**：计算 $5 | 3$

- $5$ 的二进制：$101$
- $3$ 的二进制：$011$
- 运算结果：$111$（对应十进制 $7$）

**用途**：设置某一位（如 $x | (1<<k)$ 将第 $k$ 位设为 1）、合并状态。

### 3. 按位异或（^）

**规则**：两个二进制位不同时为 $1$，相同时为 $0$。

**示例**：计算 $5 \wedge 3$
- $5$ 的二进制：$101$
- $3$ 的二进制：$011$
- 运算结果：$110$（对应十进制 $6$）

**用途**：翻转某一位（如 $x \oplus(1<<k)$ 将第 $k$ 位 $0 $变 $1$、$1$ 变 $0$）。

### 4. 左移（<<）

**规则**：将二进制位整体向左移动 $n$ 位，右侧补$ 0$。

**示例**：计算 $5 << 2$

- $5$ 的二进制：$101$
- 左移 $2 $ 位后：$10100$（对应十进制 $20$）

**等价**：$x << n$ 相当于 $x \times 2^n$（不考虑溢出时）。

**用途**：快速计算 $2$ 的幂（$1 << k$ 表示 $2^k$）、生成掩码（如 $(1<<n) - 1$ 生成 $n$ 个 $1$ 的二进制数）。

### 5. 右移（>>）

**规则**：将二进制位整体向右移动 $n$ 位，左侧补符号位（正数补 $0$，负数补 $1$）。

**示例**：计算 $5 >> 1$

- $5$ 的二进制：$101$
- 右移 1 位后：$10$（对应十进制 $2$）

**等价**：$x >> n$ 相当于 $x // 2^n$（整数除法）。

**用途**：快速除以 $2$ 的幂、提取高位。

## 二、二进制枚举：用位运算遍历所有子集

二进制枚举是位运算最经典的应用之一，核心思想是用一个整数的二进制表示集合的子集 —— 每一位对应一个元素是否被选中（$1$ 表示选中，$0$ 表示未选中）。

### 1. 基本原理

假设有 $n$ 个元素（编号 $0\sim n-1$），则所有子集可以用 $0$ 到 $2^n-1$ 的整数表示：

- 整数 `mask` 的第 $k$ 位为 $1$ → 子集包含第 $k$ 个元素；
- 整数 `mask `的第 $k$ 位为 $0$ → 子集不包含第 $k$ 个元素。

例如 $ n=3$ 时：
- `mask=5`（二进制 $101$）→ 子集包含元素 $0$ 和 $2$；
- `mask=3`（二进制 $011$）→ 子集包含元素 $0$ 和 $1$。

### 2. 实战：子集和问题

**问题**：给定 $n$ 个整数（$n \le 20$），判断是否存在非空子集，其元素和等于目标值 $t$。

**思路**：用二进制枚举所有非空子集，计算每个子集的和并判断是否等于 $t$。

### 代码实现：

```cpp
#include <iostream>

using namespace std;

const int N = 20;

int n, t;
int a[N];

int main() {
    cin >> n >> t;
    
    for (int i = 0; i < n; i ++ ) cin >> a[i];
    
    bool found = false;
    // 枚举所有非空子集 (mask从1开始，因为0表示空集)
    for (int mask = 1; mask < (1 << n); mask ++ ) {
        int sum = 0;
        for (int i = 0; i < n; i ++ )
            if (mask & (1 << i))
                sum += a[i];
        
        if (sum == t) {
            found = true;
            break;
        }
    }
    cout << (found ? "Yes" : "No") << endl;
    
    return 0;
}
```

### 3. 优化与注意事项

- **时间复杂度**：$O(n \times 2^n)$，$n=20$ 时约 200 万次运算，可接受；$n$ 超过 $20$ 时需更优算法（如 `meet-in-the-middle`）。
- **空间优化**：无需额外数组存储子集，直接用 `mask` 表示，节省空间。
- **技巧**：枚举时可跳过明显超过目标值的子集（剪枝），例如累加过程中 $sum>t $ 时提前 break。

## 三、进阶应用：从枚举到状态压缩

二进制枚举的本质是 "用整数表示状态"，这一思想可推广到更复杂的场景：

- **状态压缩 DP**：如 TSP 问题中用 mask 表示已访问的城市（见前文），将状态从 "无法存储" 压缩为整数。
- **位运算优化**：例如求多个集合的交集`（mask1 & mask2）`、并集 `mask1 | mask2）`，操作时间 $O(1)$。
- **计数问题**：统计满足条件的子集数量，例如 "包含 k 个元素的子集有多少个"，可通过枚举 mask 并计算二进制中 1 的个数（`__builtin_popcount(mask)`）实现。

## 四、总结：从符号到思维

位运算的学习路径应该是：

1. 熟练掌握 $ \& $、$ | $、$ \wedge $、$ << $、$ >> $ 的运算规则（配合二进制示例记忆）；
2. 理解 "位→状态" 的映射关系（$1$ 位表示 $1$ 个布尔状态）；
3. 用二进制枚举解决子集问题，体会状态压缩的优势；
4. 拓展到 DP、计数等高级场景，形成 "用位运算简化问题" 的思维。

位运算比想象中更直观 —— 它本质上是用计算机最自然的方式处理数据，掌握后能大幅提升代码效率与解题思路。