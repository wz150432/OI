# 二分

二分是一种高效的查找算法，其通过反复将搜索区间 “对半分割”，快速定位目标值。它依赖答案集合的单调性来求解最优解，是典型的 “分治思想” 应用，时间复杂度低至 $O(log n)$。



## 整数二分

1. 编写 **问题特定的检查函数**（用于确定中点值是否对您的目标 "有效"）
2. 选择正确的中点计算方式以避免无限循环（初学者的常见陷阱）

### 寻找最大有效值

此变体适用于找到满足检查函数的**最大值**，我们将区间`[l, r]`分成两部分：

- `[l, mid - 1]`（无效的一半）

- `[mid, r]` (有效的一半)

```cpp
int binary_search1() {
    int l = 1, r = n;
    while (l < r) {
        int mid = (l + r + 1) >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return r;
}
```

### 寻找最小有效值

此变体适用于找到满足检查函数的**最小值**，我们将区间`[l, r]`分成两部分：

- `[mid + 1, r]`（无效的一半）

- `[l, mid]`（有效的一半）

```cpp
int binary_search2() {
    int l = 1, r = n;
    while (l < r) {
        int mid = (l + r) >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    return r;
}
```

最关键的就是中点的计算方式，一个加 $1$， 一个不加。我们只需要考虑 $r = l + 1$ 的情况即可考虑清楚。

## 实数二分

实数二分查找用于答案位于**连续范围**的情况（例如，温度、距离或平方根等浮点值）。与整数二分不同，我们不依赖离散索引 —— 而是缩小区间直到足够小以满足问题的精度要求。

```cpp
double binary_search3() {
    double eps = 1e-8;
    double l = -100, r = 100;
    while (r - l > eps) {
        double mid = (l + r) / 2;
        if (check(mid)) l = mid;
        else r = mid;
    }
    return l;
}
```

#### 精度 eps 的设置

这是实数二分的核心！如果题目要求答案精确到`1e-6`（小数点后 $6 $位），若设`eps = 1e-6`，可能因浮点误差导致最终结果四舍五入错误；设`eps = 1e-8`（多 $2$ 位），能确保区间缩小到足够小，最终结果更可靠



## 例题

[P3184](https://www.luogu.com.cn/problem/P3184)

[P1024](https://www.luogu.com.cn/problem/P1024)



## 推荐的练习

[P2678](https://www.luogu.com.cn/problem/P2678)

[P10450](https://www.luogu.com.cn/problem/P10450)

[CF782B](https://codeforces.com/problemset/problem/782/B)

[CF1117C](https://codeforces.com/problemset/problem/1117/C)