# 对拍的流程

- ### 首先就是一个保证正确性的暴力程序和正确性未知的正解。
- ### 然后就是根据这个题目写的用来制造随机数据的文件
- ### 写一个 shell 脚本或者 cpp 文件（不推荐）

#

## 一. 脚本的书写：
### shell 脚本 (Linux 系统下运行)：
```sh
#!/bin/bash
g++ my.cpp -std=c++11 -o my #正解
g++ bf.cpp -std=c++11 -o bf #暴力
g++ rand.cpp -std=c++11 -o rand #随机数据

t=1
while [ $t -lt 1000000 ]; do
    printf "CASE%d:\n" $t
    
    # < 输入 > 输出每次会覆盖原来的数据，如果不想覆盖可以 << 输入 >> 输出
    
    ./rand > rand.in #制造的数据放入rand.in文件里
    
    ./bf < rand.in > bf.out #输入rand.in文件的数据输出放到bf.out
    
    time ./my < rand.in > my.out #输入rand.in文件的数据输出放到my.out，顺便显示运行时间
    
    # -Z 是忽略行尾的空格差异
    if diff -Z bf.out my.out; then 
        echo "AC\n"
    else 
        echo "WA\n"
        cat rand.in #可以不写自己打开也行
        break;
    
    fi #结束if
    
    let "t = $t + 1"
done
```

### cpp 脚本（Windows下运行的）：
```cpp
#include <chrono>
#include <cstdio>

using namespace std;

int c;

int main() {
    system("g++ my.cpp -std=c++11 -o my.exe");
    system("g++ rand.cpp -std=c++11 -o rand.exe");
    system("g++ bf.cpp -std=c++11 -o bf.exe");
    
    
    while (c <= 1000000) {
        system("rand.exe > rand.in");
        system("bf.exe < rand.in > bf.out");
        
        double st = clock();
        system("test.exe < rand.in > test.out");
        double ed = clock();
        
        if (system("fc test.out bf.out > nul")) {
            printf("#CASE%d: WA, cost time: %.0lfms\n", ++ c, ed - st);
            break;
        }
        printf("#CASE%d: AC, cost time: %.0lfms\n", ++ c, ed - st);
    }

    return 0;
}
```

如果想让上面的代码能够在 Linux 下运行可以参考一开始的代码进行修改。

#
#
## 二. 随机数据文件的书写
```cpp
#include<cstdlib>
#include <ctime>

using namespace std;

typedef long long ll;

// 由于rand函数在windows的范围是 [0 - 32767] 对于数字范围较大的数据可以多乘几次
// 但是rand函数在类unix系统的范围是 [0 - 2147483647] 一定注意区分别生成的数据爆了
// 下面的代码生成范围都是 [0 - n - 1] 如果想要负数可以生成 [0 - 2n] 的数据后减去 n

int ri(int n) {
    return 1ll * rand() * rand() % n;
}

ll rll(ll n) {
    return 1ll * rand() * rand() % n;
}

int main() {
    srand(time(0);
    
    return 0;
}
```

随机生成 $n$ 个节点的树，有 $n - 1$ 条边的无向图
```cpp
int n = ri(100000);

for (int i = 2 ; i <= n ; i ++ )  {
    int p = ri(i - 1) + 1;
    int val = ri(1000000000) + 1;
    printf("%d %d %d\n", p, i, val);
}
```

随机生成 $n$ 个节点 $m$ 条边的无向图，图中不存在重边和自环，且必须连通
```cpp
typedef pair<int, int> PII;
PII e[N];
map<PII, bool> vis;

for (int i = 1 ; i < n ; i ++ ) {
    int p = ri(i) + 1;
    e[i] = {p, i + 1};
    vis[e[i]] = vis[{i + 1, p)] = 1;
}

for (int i = n ; i <= m ; i ++ ) {
    int x = -2e9, y = -2e9;
    while (x == y || vis[{x, y}])
        x = ri(n) + 1, y = ri(n) + 1;
    
    e[i] = {x, y}
    vis[e[i] = vis[{y, x] = 1;
}

random_shuffle(e + 1, e + m + 1);
for (int i = 1 ; i <= m ; i ++ ) 
    printf("%d %d\n", e[i].first, e[i].second);
```
