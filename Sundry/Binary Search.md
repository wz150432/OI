# 二分

## 1. 核心原理

二分查找的核心原理很简单：对于**有序数据集**，您可以通过单次检查排除一半剩余元素。通过将 "中点" 值与目标值或问题特定条件进行比较，您可以将搜索空间缩小到左半部分或右半部分。这种对半分割的过程持续进行，直到找到答案或穷尽搜索区间。

## 2. 整数二分查找

整数二分查找的两个关键细节：

1. 编写 **问题特定的检查函数**（用于确定中点值是否对您的目标 "有效"）
2. 选择正确的中点计算方式以避免无限循环（初学者的常见陷阱）

### 变体 1：寻找最大有效值

此变体适用于需要找到满足检查函数的**最大值**的场景（例如："在有序数组中找小于等于 `target` 的最大数"、"最多能分配多少资源仍满足条件"）。

我们将区间`[l, r]`分成两部分：

- `[l, mid - 1]`（无效的一半）
- `[mid, r]`（有效的一半）

#### 代码实现：

```cpp
int binary_search1() {
    int l = 1, r = n;
    while (l < r) {
        int mid = (l + r + 1) >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return r;
}
```

#### 关键解析：为什么中点要加 1？

这是避免无限循环的核心！假设区间缩小到`l = 2，r = 3`

- 若用`(l + r) >> 1`计算 `mid`，结果为 $2$ ；若`check(2)`返回 $true$（$2$ 是有效解），则`l = 2`，区间仍为`[2,3]`，循环永远无法结束；
- 用`(l + r + 1) >> 1`计算 `mid`，结果为 $3$ ；若`check(3)`返回 $true$，则`l = 3`，此时`l = r`，循环正常结束。

### 变体 2：寻找最小有效值

此变体目标是找到通过检查函数的**最小值**（例如："在有序数组中找大于等于 target 的最小数"、"最少需要多少资源能完成任务"）。

我们将区间`[l, r]`分成两部分：

- `[mid + 1, r]`（无效的一半）

- `[l, mid]`（有效的一半）

#### 代码实现：

```cpp
int binary_search2() {
    int l = 1, r = n;
    while (l < r) {
        int mid = (l + r) >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    return r;
}
```

#### 关键解析：为什么中点不加 1？

同样以`l = 2，r = 3`为例

- 若用`(l + r + 1) >> 1`计算 `mid`，结果为 3；若`check(3)`返回 $true$，则`r = 3`，区间仍为`[2, 3]`，陷入无限循环；

- 用`(l + r) >> 1`计算 mid，结果为 $2$；若`check(2)`返回 $false$（$2$ 无效），则`l = 3`，`l = r`，循环正常结束。

## 3. 实数二分查找

实数二分查找用于答案位于**连续范围**的情况（例如，温度、距离或平方根等浮点值）。与整数二分不同，我们不依赖离散索引 —— 而是缩小区间直到足够小以满足问题的精度要求。

### 代码实现：

```cpp
double binary_search3() {
    double eps = 1e-8;
    double l = -100, r = 100;
    while (r - l > eps) {
        double mid = (l + r) / 2;
        if (check(mid)) l = mid;
        else r = mid;
    }
    return l;
}
```

#### 关键解析：精度 eps 的设置

这是实数二分的核心！如果题目要求答案精确到`1e-6`（小数点后 $6 $位），若设`eps = 1e-6`，可能因浮点误差导致最终结果四舍五入错误；设`eps = 1e-8`（多 $2$ 位），能确保区间缩小到足够小，最终结果更可靠